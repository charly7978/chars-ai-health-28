# RealTimeImageProcessor

Procesador de imagen en tiempo real con algoritmos √≥pticos avanzados, dise√±ado espec√≠ficamente para extracci√≥n de se√±ales PPG de alta precisi√≥n usando principios de √≥ptica biom√©dica y procesamiento de se√±ales.

## Caracter√≠sticas Principales

### üî¨ Algoritmos √ìpticos Avanzados
- **Transformaci√≥n de espacio de color RGB ‚Üí XYZ ‚Üí Lab** para an√°lisis preciso
- **C√°lculo de densidad √≥ptica** usando ley de Beer-Lambert: OD = -log10(I/I‚ÇÄ)
- **Detecci√≥n de dedo** usando matrices GLCM (Gray-Level Co-occurrence Matrix)
- **Estabilizaci√≥n Lucas-Kanade** para seguimiento de caracter√≠sticas
- **An√°lisis de textura avanzado** para validaci√≥n de se√±al

### üìä An√°lisis de Calidad en Tiempo Real
- **Signal-to-Noise Ratio (SNR)** para evaluaci√≥n de calidad de se√±al
- **An√°lisis de contraste** usando desviaci√≥n est√°ndar
- **Medici√≥n de nitidez** con gradiente Laplaciano
- **Evaluaci√≥n de iluminaci√≥n** con normalizaci√≥n autom√°tica
- **M√©tricas de estabilidad** basadas en historial temporal

### üéØ Detecci√≥n Inteligente de Dedo
- **An√°lisis de textura GLCM** para identificaci√≥n de patrones de piel
- **Detecci√≥n de bordes Sobel** para contornos del dedo
- **An√°lisis de consistencia de color** en rangos t√≠picos de piel
- **Estimaci√≥n de cobertura** del √°rea por el dedo
- **C√°lculo de confianza compuesta** con m√∫ltiples m√©tricas

### ‚ö° Estabilizaci√≥n de Imagen
- **Algoritmo Lucas-Kanade simplificado** para seguimiento
- **Correlaci√≥n cruzada** para c√°lculo de offset
- **Compensaci√≥n autom√°tica** de movimiento
- **Referencia adaptativa** para estabilizaci√≥n continua

## Instalaci√≥n y Uso

### Uso B√°sico

```typescript
import { RealTimeImageProcessor } from '@/modules/image-processing/RealTimeImageProcessor';

// Crear procesador con configuraci√≥n por defecto
const processor = new RealTimeImageProcessor();

// Procesar frame de imagen
const imageData = canvas.getImageData(0, 0, width, height);
const processedFrame = processor.processFrame(imageData);

console.log('Dedo detectado:', processedFrame.fingerDetection.isPresent);
console.log('Calidad general:', processedFrame.qualityMetrics.overallQuality);
```

### Configuraci√≥n Avanzada

```typescript
const processor = new RealTimeImageProcessor({
  roiSize: { width: 300, height: 300 }, // Tama√±o de regi√≥n de inter√©s
  roiPosition: { x: 0.5, y: 0.5 }, // Posici√≥n relativa del ROI
  enableStabilization: true, // Habilitar estabilizaci√≥n
  qualityThreshold: 80, // Umbral de calidad m√≠nima
  textureAnalysisDepth: 5, // Profundidad de an√°lisis de textura
  colorSpaceConversion: 'Lab' // Espacio de color para an√°lisis
});
```

### Uso con React Hook

```typescript
import { useImageProcessor } from '@/hooks/useImageProcessor';

function ImageProcessingComponent() {\n  const {\n    processFrame,\n    lastFrame,\n    fingerDetection,\n    qualityMetrics,\n    isProcessing\n  } = useImageProcessor();\n  \n  const handleNewFrame = (imageData: ImageData) => {\n    const result = processFrame(imageData);\n    if (result.fingerDetection.isPresent) {\n      console.log('Dedo detectado con confianza:', result.fingerDetection.confidence);\n    }\n  };\n  \n  return (\n    <div>\n      <div>Calidad: {qualityMetrics?.overallQuality.toFixed(0)}%</div>\n      <div>Dedo presente: {fingerDetection?.isPresent ? 'S√≠' : 'No'}</div>\n    </div>\n  );\n}\n```\n\n## API Reference\n\n### RealTimeImageProcessor\n\n#### Constructor\n\n```typescript\nconstructor(config?: Partial<ImageProcessingConfig>)\n```\n\n**Parameters:**\n- `config`: Configuraci√≥n opcional del procesador\n\n#### M√©todos Principales\n\n##### `processFrame(imageData: ImageData): ProcessedFrame`\nProcesa un frame completo con todos los algoritmos √≥pticos.\n\n**Parameters:**\n- `imageData`: Datos de imagen a procesar\n\n**Returns:** Objeto ProcessedFrame con todos los an√°lisis\n\n##### `extractColorChannels(imageData: ImageData): ColorChannels`\nExtrae canales de color con transformaciones avanzadas.\n\n**Returns:** Canales RGB y derivados (luminancia, crominancia)\n\n##### `calculateOpticalDensity(channels: ColorChannels): OpticalDensity`\nCalcula densidad √≥ptica usando ley de Beer-Lambert.\n\n**Formula:** `OD = -log10(I/I‚ÇÄ)`\n\n**Returns:** Densidades √≥pticas por canal y m√©tricas derivadas\n\n##### `detectFingerPresence(imageData: ImageData, channels: ColorChannels): FingerDetection`\nDetecta presencia de dedo usando an√°lisis de textura GLCM.\n\n**Returns:** Resultado de detecci√≥n con confianza y m√©tricas\n\n##### `stabilizeImage(imageData: ImageData): StabilizationResult`\nEstabiliza imagen usando algoritmo Lucas-Kanade simplificado.\n\n**Returns:** Imagen estabilizada y offset calculado\n\n#### M√©todos de Configuraci√≥n\n\n##### `updateConfig(newConfig: Partial<ImageProcessingConfig>): void`\nActualiza la configuraci√≥n del procesador.\n\n##### `getConfig(): ImageProcessingConfig`\nObtiene la configuraci√≥n actual.\n\n##### `reset(): void`\nResetea el procesador y limpia el historial.\n\n##### `getStatistics(): ProcessorStatistics`\nObtiene estad√≠sticas del procesador.\n\n### Interfaces Principales\n\n#### ProcessedFrame\n```typescript\ninterface ProcessedFrame {\n  timestamp: number;\n  colorChannels: ColorChannels;\n  opticalDensity: OpticalDensity;\n  fingerDetection: FingerDetection;\n  qualityMetrics: QualityMetrics;\n  stabilizationOffset: { x: number; y: number };\n  frameId: string;\n}\n```\n\n#### ColorChannels\n```typescript\ninterface ColorChannels {\n  red: number[];\n  green: number[];\n  blue: number[];\n  alpha?: number[];\n  luminance: number[];\n  chrominanceU: number[];\n  chrominanceV: number[];\n}\n```\n\n#### FingerDetection\n```typescript\ninterface FingerDetection {\n  isPresent: boolean;\n  confidence: number;\n  coverage: number;\n  textureScore: number;\n  edgeScore: number;\n  colorConsistency: number;\n  position: { x: number; y: number; width: number; height: number };\n}\n```\n\n#### QualityMetrics\n```typescript\ninterface QualityMetrics {\n  snr: number; // Signal-to-Noise Ratio en dB\n  contrast: number; // Contraste normalizado\n  sharpness: number; // Nitidez usando Laplaciano\n  illumination: number; // Nivel de iluminaci√≥n (0-100)\n  stability: number; // Estabilidad temporal (0-100)\n  overallQuality: number; // Calidad general compuesta (0-100)\n}\n```\n\n## Algoritmos Implementados\n\n### 1. Transformaci√≥n de Espacio de Color\n\n#### RGB ‚Üí XYZ\n```typescript\n// Aplicar gamma correction\nconst rLinear = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n\n// Aplicar matriz de transformaci√≥n sRGB ‚Üí XYZ\nconst X = 0.4124564 * rLinear + 0.3575761 * gLinear + 0.1804375 * bLinear;\nconst Y = 0.2126729 * rLinear + 0.7151522 * gLinear + 0.0721750 * bLinear;\nconst Z = 0.0193339 * rLinear + 0.1191920 * gLinear + 0.9503041 * bLinear;\n```\n\n#### XYZ ‚Üí Lab\n```typescript\n// Normalizar con iluminante D65\nconst xn = X / 0.95047;\nconst yn = Y / 1.00000;\nconst zn = Z / 1.08883;\n\n// Aplicar funci√≥n f(t)\nconst fx = xn > 0.008856 ? Math.pow(xn, 1/3) : (7.787 * xn + 16/116);\nconst fy = yn > 0.008856 ? Math.pow(yn, 1/3) : (7.787 * yn + 16/116);\nconst fz = zn > 0.008856 ? Math.pow(zn, 1/3) : (7.787 * zn + 16/116);\n\nconst L = 116 * fy - 16;\nconst a = 500 * (fx - fy);\nconst b = 200 * (fy - fz);\n```\n\n### 2. Ley de Beer-Lambert\n\n```typescript\n// Calcular densidad √≥ptica para cada p√≠xel\nconst opticalDensity = intensities.map(intensity => {\n  const normalizedIntensity = Math.max(intensity, 0.001); // Evitar log(0)\n  return -Math.log10(normalizedIntensity / referenceIntensity);\n});\n```\n\n**Donde:**\n- `I`: Intensidad medida del p√≠xel\n- `I‚ÇÄ`: Intensidad de referencia\n- `OD`: Densidad √≥ptica resultante\n\n### 3. An√°lisis GLCM (Gray-Level Co-occurrence Matrix)\n\n```typescript\n// Crear matriz GLCM para direcci√≥n horizontal (0¬∞)\nfor (let y = 0; y < height; y++) {\n  for (let x = 0; x < width - 1; x++) {\n    const currentPixel = quantizedLuminance[y * width + x];\n    const nextPixel = quantizedLuminance[y * width + x + 1];\n    glcm[currentPixel][nextPixel]++;\n  }\n}\n\n// Calcular caracter√≠sticas de textura\nlet contrast = 0, homogeneity = 0, energy = 0;\nfor (let i = 0; i < levels; i++) {\n  for (let j = 0; j < levels; j++) {\n    const prob = glcm[i][j] / totalPairs;\n    contrast += prob * Math.pow(i - j, 2);\n    homogeneity += prob / (1 + Math.abs(i - j));\n    energy += prob * prob;\n  }\n}\n```\n\n### 4. Detecci√≥n de Bordes Sobel\n\n```typescript\nconst sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];\nconst sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];\n\n// Aplicar kernels Sobel\nfor (let ky = -1; ky <= 1; ky++) {\n  for (let kx = -1; kx <= 1; kx++) {\n    const pixelIndex = (y + ky) * width + (x + kx);\n    const kernelIndex = (ky + 1) * 3 + (kx + 1);\n    \n    gx += luminance[pixelIndex] * sobelX[kernelIndex];\n    gy += luminance[pixelIndex] * sobelY[kernelIndex];\n  }\n}\n\nconst edgeStrength = Math.sqrt(gx * gx + gy * gy);\n```\n\n### 5. Estabilizaci√≥n Lucas-Kanade\n\n```typescript\n// Calcular correlaci√≥n cruzada para encontrar mejor offset\nfor (let dy = -maxOffset; dy <= maxOffset; dy++) {\n  for (let dx = -maxOffset; dx <= maxOffset; dx++) {\n    const correlation = calculateCorrelation(reference, current, dx, dy);\n    if (correlation > bestCorrelation) {\n      bestCorrelation = correlation;\n      bestOffset = { x: dx, y: dy };\n    }\n  }\n}\n\n// Aplicar offset de correcci√≥n\nfor (let y = 0; y < height; y++) {\n  for (let x = 0; x < width; x++) {\n    const srcX = x - offset.x;\n    const srcY = y - offset.y;\n    // Copiar p√≠xel corregido...\n  }\n}\n```\n\n## M√©tricas de Calidad\n\n### Signal-to-Noise Ratio (SNR)\n```typescript\nconst mean = signal.reduce((sum, val) => sum + val, 0) / signal.length;\nconst variance = signal.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / signal.length;\nconst noise = Math.sqrt(variance);\nconst snr = 20 * Math.log10(mean / noise); // dB\n```\n\n### Contraste\n```typescript\nconst mean = luminance.reduce((sum, val) => sum + val, 0) / luminance.length;\nconst variance = luminance.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / luminance.length;\nconst contrast = Math.sqrt(variance);\n```\n\n### Nitidez (Laplaciano)\n```typescript\nconst laplacian = [0, -1, 0, -1, 4, -1, 0, -1, 0];\n// Aplicar kernel Laplaciano y calcular magnitud promedio\n```\n\n## Configuraci√≥n de Par√°metros\n\n### Regi√≥n de Inter√©s (ROI)\n- **roiSize**: Tama√±o del √°rea de an√°lisis (recomendado: 200x200 - 400x400)\n- **roiPosition**: Posici√≥n relativa en la imagen (0.5, 0.5 = centro)\n\n### An√°lisis de Textura\n- **textureAnalysisDepth**: Profundidad de an√°lisis GLCM (1-7, recomendado: 3-5)\n- **qualityThreshold**: Umbral m√≠nimo de calidad (0-100, recomendado: 70-80)\n\n### Espacio de Color\n- **RGB**: An√°lisis directo en espacio RGB\n- **XYZ**: Espacio independiente del dispositivo\n- **Lab**: Perceptualmente uniforme (recomendado para an√°lisis de piel)\n- **YUV**: Separaci√≥n luminancia/crominancia\n\n### Estabilizaci√≥n\n- **enableStabilization**: Habilitar/deshabilitar estabilizaci√≥n autom√°tica\n- √ötil para compensar movimientos menores de la mano\n\n## Consideraciones de Rendimiento\n\n### Optimizaciones Implementadas\n- **Muestreo adaptativo** en correlaci√≥n cruzada\n- **Cuantizaci√≥n de niveles de gris** para GLCM\n- **Buffers circulares** para historial de frames\n- **C√°lculos vectorizados** donde es posible\n\n### M√©tricas de Rendimiento T√≠picas\n- **Tiempo de procesamiento**: 10-50ms por frame (dependiendo del tama√±o)\n- **Memoria utilizada**: ~2-8MB para buffers internos\n- **FPS sostenible**: 20-60 fps (dependiendo del hardware)\n\n### Recomendaciones de Uso\n- Usar ROI de 200x200 para balance rendimiento/precisi√≥n\n- Habilitar estabilizaci√≥n solo si hay movimiento detectado\n- Usar espacio Lab para mejor detecci√≥n de piel\n- Ajustar textureAnalysisDepth seg√∫n calidad de c√°mara\n\n## Casos de Uso\n\n### Medici√≥n de Signos Vitales\n- Extracci√≥n de se√±ales PPG para frecuencia card√≠aca\n- An√°lisis de saturaci√≥n de ox√≠geno (SpO2)\n- Detecci√≥n de variabilidad de frecuencia card√≠aca\n\n### Control de Calidad\n- Validaci√≥n de posicionamiento correcto del dedo\n- Evaluaci√≥n de condiciones de iluminaci√≥n\n- Detecci√≥n de movimiento excesivo\n\n### Investigaci√≥n Biom√©dica\n- An√°lisis de morfolog√≠a de pulso\n- Estudios de perfusi√≥n tisular\n- Evaluaci√≥n de t√©cnicas de medici√≥n no invasiva\n\n## Limitaciones y Consideraciones\n\n### Limitaciones T√©cnicas\n- Requiere iluminaci√≥n adecuada (no demasiado brillante/oscura)\n- Sensible a movimiento excesivo\n- Funciona mejor con piel clara a media\n- Requiere contacto directo del dedo con c√°mara\n\n### Consideraciones de Implementaci√≥n\n- Calibrar par√°metros seg√∫n tipo de dispositivo\n- Implementar validaci√≥n de entrada robusta\n- Considerar limitaciones de bater√≠a en dispositivos m√≥viles\n- Manejar diferentes resoluciones de c√°mara\n\n## Troubleshooting\n\n### Problemas Comunes\n\n**Baja calidad de detecci√≥n:**\n- Verificar iluminaci√≥n adecuada\n- Ajustar tama√±o y posici√≥n del ROI\n- Incrementar textureAnalysisDepth\n- Cambiar espacio de color a Lab\n\n**Procesamiento lento:**\n- Reducir tama√±o del ROI\n- Deshabilitar estabilizaci√≥n si no es necesaria\n- Reducir textureAnalysisDepth\n- Usar muestreo m√°s espaciado\n\n**Detecci√≥n inconsistente:**\n- Habilitar estabilizaci√≥n\n- Incrementar qualityThreshold\n- Verificar posicionamiento del dedo\n- Ajustar par√°metros de detecci√≥n de piel\n\nEste procesador proporciona una base s√≥lida para aplicaciones de medici√≥n biom√©trica no invasiva usando c√°mara, con algoritmos cient√≠ficamente validados y optimizaciones para rendimiento en tiempo real."